(ns cassiel.cubewar.db
  "Database wrapper."
  (:require (clojure.java [jdbc :as sql])
            (cassiel.cubewar [manifest :as m]))
  (:use [slingshot.slingshot :only [try+ throw+]])
  (:import [java.sql BatchUpdateException]
           [org.apache.commons.codec.digest DigestUtils]))

(defprotocol LEAGUE
  "Interface to DB representing a league."
  (clear [this] "Drop all tables and recreate.")
  (initialize [this] "Create the initial test/usage state.")
  (add-user [this user pass rgb] "Add a user with this password and display colour.")
  (lookup-id [this user] "Look up an ID from a username. (Probably not needed.)")
  (lookup-user [this id] "Look up user details as a map.")
  (lookup-rgb [this user] "Look up a user's RGB value.")
  (authenticate [this user pass] "Authenticate (returning an ID), or return null.")
  (num-users [this] "Return number of users.")
  (out-of-round [this name] "Round is over for this player.")
  (winner [this name] "Bump the win count for this player.")
  (score [this name] "Get the score as `{:played X :won Y}`.")
  (league [this] "Get the entire league table."))

(defn- crypt
  "SHA1 encryption. Not very smart (no salting), but this is only a game; this is
   really just to avoid password leakage from HSQLDB's database files."
  [string]
  (DigestUtils/sha1Hex string))

(def spec-template
  {:subprotocol "hsqldb"
   :user "SA"
   :password ""})

(defn- mem-db-spec
  "A specification for an in-memory database."
  [name]
  (assoc spec-template
    :subname
    (str "mem:" name)))

(defn- file-db-spec
  "A specification for a file-based database. Path is rooted in home directory;
   we add the initial separator. (So, best keep it as a single token.)"
  [path]
  (assoc spec-template
    :subname
    (str "file:"
         (System/getProperty "user.home")
         java.io.File/separator
         path
         #_ ";shutdown=true")))

(def ID [:id "INTEGER" "GENERATED BY DEFAULT AS IDENTITY (START WITH 1) PRIMARY KEY"])

(defn- make-db
  "Create a database from a spec."
  [db]
  (reify LEAGUE
    (clear [this]
      (sql/with-connection db
        (try+
         (sql/drop-table :Users)
         (catch BatchUpdateException _ this))

        (sql/create-table
         :Users
         ID
         [:Username "VARCHAR(255)" "NOT NULL"]
         [:Password "VARCHAR(255)" "NOT NULL"]
         [:RGB "INTEGER" "NOT NULL"]
         [:Played "INTEGER" "NOT NULL"]
         [:Won "INTEGER" "NOT NULL"]))

      this)

    (initialize [this]
      (-> this
          (clear)
          (add-user "Demo1" "Pass1" 0xFFFFFF)
          (add-user "Demo2" "Pass2" 0xFFFFFF)
          (add-user "Demo3" "Pass3" 0xFFFFFF)
          (add-user m/OBSERVER-NAME "xyzzy" 0x303030)))

    (add-user [this user pass rgb]
      (if (lookup-id this user)
        (throw+ {:type ::DUPLICATE-USER})
        (sql/with-connection db
          (sql/insert-record :Users {:Username user
                                     :Password (crypt pass)
                                     :RGB rgb
                                     :Played 0
                                     :Won 0})))

      this)

    ;; TODO do we need this? (Only in `add-user` perhaps.)
    (lookup-id [this name]
      (sql/with-connection db
        (sql/with-query-results rows
          ["SELECT ID FROM Users WHERE Username = ?" name]
          (:id (first rows)))))

    (lookup-rgb [this name]
      (sql/with-connection db
        (sql/with-query-results rows
          ["SELECT RGB FROM Users WHERE Username = ?" name]
          (:rgb (first rows)))))

    (lookup-user [this id]
      (sql/with-connection db
        (sql/with-query-results rows
          [(str "SELECT Username AS User, "
                "       RGB AS RGB "
                "FROM Users WHERE ID = ?") id]
          (if (seq rows)
            (first rows)
            (throw+ {:type ::INTERNAL :source 'lookup-user})))))

    (authenticate [this name pass]
      (let [c (crypt pass)]
        (sql/with-connection db
          (sql/with-query-results rows
            ["SELECT ID FROM Users WHERE Username = ? AND Password = ?" name c]
            (if (seq rows)
              (:id (first rows))
              (throw+ {:type ::AUTH-FAILED}))))))

    (num-users [this]
      (sql/with-connection db
        (sql/with-query-results rows
          ["SELECT Count(*) AS C FROM Users"]
          (:c (first rows)))))

    (out-of-round [this name]
      ;; The `str` conversion here (and in `winner`) is for dealing with all the tests
      ;; where we are using keywords for players (and have no DB entries for them).
      (sql/with-connection db
        (sql/do-prepared "UPDATE Users SET Played = Played + 1 WHERE Username = ?" [(str name)])))

    (winner [this name]
      (sql/with-connection db
        (sql/do-prepared "UPDATE Users SET Won = Won + 1 WHERE Username = ?" [(str name)])))

    (score [this name]
      (sql/with-connection db
        (sql/with-query-results rows
          ["SELECT Played, Won FROM Users WHERE Username = ?" name]
          (if (seq rows)
            {:played (:played (first rows)) :won (:won (first rows))}
            (throw+ {:type ::NO-SUCH-USER :name name})))))

    (league [this]
      (sql/with-connection db
        (sql/with-query-results rows
          [(str "SELECT Username AS Name, Played, Won "
                "  FROM Users "
                " ORDER BY Won DESC, Played DESC, Name ASC")]
          (doall rows))))))

(defn mem-db
  "Create a database in memory (for testing)."
  [name]
  (make-db (mem-db-spec name)))

(defn file-db
  "Create a database on disk."
  [path]
  (make-db (file-db-spec path)))

(defn ordinal-keys [prefix items]
  (first
   (reduce (fn [[m i] x] [(assoc m (keyword (str prefix i)) x) (inc i)])
           [{} 0]
           items)))

(defn league-to-dict
  [db]
  (ordinal-keys "_" (league db)))
